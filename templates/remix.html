<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Mini DAW ‚Äì Serato-style BPM Detection</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{ --bg:#121212;--panel:#1d1d1d;--grid:#252525;--accent:#3db7ff;--accent2:#1bc477;--text:#e9eef3; --pxGrid:80px; --leftCol:300px;}
  *{box-sizing:border-box}
  body{margin:0;font-family:Inter,system-ui,Arial,sans-serif;background:#121212;color:var(--text)}
  header{display:flex;flex-wrap:wrap;gap:.5rem;align-items:center;padding:.6rem 1rem;background:#0e0e0e;border-bottom:1px solid #000;position:sticky;top:0;z-index:100}
  header h1{font-size:1rem;font-weight:600;margin:0 .5rem 0 0;color:#3db7ff}
  .btn{padding:.45rem .7rem;border:0;border-radius:.4rem;background:#2a2a2a;color:var(--text);cursor:pointer}
  .btn.good{background:#1bc477;color:#012b17}
  .btn.primary{background:#3db7ff;color:#001a2a}
  .btn.danger{background:#e94256}
  .sep{width:1px;height:28px;background:#333;margin:0 .4rem}
  .wrap{max-width:1100px;margin:12px auto}
  .panel{background:var(--panel);border-radius:10px;border:1px solid #0a0a0a;overflow:hidden}
  .timeline-wrap{position:relative;display:grid;grid-template-columns: var(--leftCol) 1fr;grid-template-rows: 36px auto}
  .ruler-left{grid-column:1;grid-row:1;background:#161616;border-bottom:1px solid #0a0a0a}
  .titles{grid-column:1;grid-row:2;background:#161616;border-right:1px solid #0a0a0a;overflow:auto;max-height:600px}
  .ruler{grid-column:2;grid-row:1;position:relative;background:#161616;border-bottom:1px solid #0a0a0a;overflow:hidden}
  .ruler canvas{position:absolute;top:0;left:0}
  .timelines{grid-column:2;grid-row:2;position:relative;overflow:auto;max-height:600px;background:#171717}
  .playhead{position:absolute;top:0;bottom:0;width:2px;background:#ffcc00;z-index:50;pointer-events:none}
  .title-row{min-height:164px;display:block;padding:.6rem;border-bottom:1px solid #0a0a0a}
  .title-head{display:flex;align-items:center;gap:.5rem;flex-wrap:wrap}
  .title-row input[type=file]{display:none}
  .meta{font-size:.75rem;opacity:.85}
  .pill{background:#2a2a2a;border:1px solid #0a0a0a;border-radius:8px;padding:.15rem .5rem}
  .fx-panel{margin:.5rem 0 .2rem 0;border:1px solid #0a0a0a;border-radius:8px;background:#131313}
  .fx-panel summary{cursor:pointer;list-style:none}
  .fx-panel summary::-webkit-details-marker{display:none}
  .fx-panel .fx-grid{display:grid;grid-template-columns:1fr;gap:.4rem;padding:.5rem}
  .fx-row{display:grid;grid-template-columns:110px 1fr 56px;gap:.4rem;align-items:center}
  .fx-row .label{font-size:.8rem;opacity:.9}
  .fx-row input[type=range]{width:100%}
  .chip{display:inline-flex;align-items:center;gap:.35rem;background:#202020;border:1px solid #0a0a0a;border-radius:999px;padding:.15rem .6rem;font-size:.75rem}
  .lanes{position:relative}
  .lane{position:relative;height:78px;border-bottom:1px solid #0a0a0a;background:repeating-linear-gradient(90deg,var(--grid) 0,var(--grid) 1px,transparent 1px,transparent calc(var(--pxGrid)))}
  .clip{position:absolute;top:14px;height:50px;border-radius:6px;border:1px solid #000;color:#001;cursor:grab;will-change:transform,width}
  .clip .label{position:absolute;left:8px;bottom:6px;font-size:.75rem;color:#012;background:#ffffff90;border-radius:4px;padding:1px 6px}
  .clip.selected{outline:2px solid #fff}
  .clip .wave{position:absolute;inset:0;border-radius:6px;opacity:.75}
  .clip .handle{position:absolute;top:0;width:8px;height:100%;cursor:ew-resize;background:#00000022}
  .clip .handle.l{left:-2px}.clip .handle.r{right:-2px}
  .status{padding:.6rem 1rem;color:#a9b5c2;display:flex;gap:1rem;flex-wrap:wrap;align-items:center}
  label{font-size:.9rem;opacity:.95}
  input[type="number"]{width:5.5rem;padding:.25rem .4rem;background:#0f0f0f;color:var(--text);border:1px solid #2a2a2a;border-radius:.35rem}
  input[type="range"]{width:160px}
  select{background:#101010;color:var(--text);border:1px solid #2a2a2a;border-radius:.35rem;padding:.25rem .35rem}
  .chip input[type="number"]{width:4.5rem}
  .chip .btn{padding:.25rem .5rem;font-size:.75rem}
</style>
</head>
<body>
  
<header>
  <h1>Mini DAW</h1>
  <button id="addTrack" class="btn">‚ûï Add Track</button>
  <div class="sep"></div>
  <button id="play" class="btn good">‚ñ∂Ô∏è Play</button>
  <button id="stop" class="btn">‚èπ Stop</button>
  <button id="split" class="btn">‚úÇÔ∏è Split</button>
  <button id="del" class="btn danger">üóë Delete</button>
  <div class="sep"></div>
  <label class="btn"><input id="match" type="checkbox"> Match BPM+Key</label>
  <button id="autoAlign" class="btn">ü§ñ Auto-Align</button>
  <button id="export" class="btn primary">üíæ Export WAV</button>
  <div style="margin-left:auto;display:flex;gap:.6rem;align-items:center">
    <label>Zoom <input id="zoom" type="range" min="20" max="300" step="1" value="80"></label>
    <label>Grid BPM <input id="bpmGrid" type="number" min="30" max="240" value="120"></label>
    <label><input id="snap" type="checkbox" checked> Snap</label>
    <select id="snapMode">
      <option value="sec">Second</option>
      <option value="beat" selected>Beat</option>
      <option value="1/4">1/4 Beat</option>
    </select>
  </div>
</header>

<div class="wrap panel">
  <div class="timeline-wrap">
    <div class="ruler-left"></div>
    <div class="titles" id="titles"></div>
    <div class="ruler"><canvas id="ruler"></canvas></div>
    <div class="timelines" id="timelines">
      <div class="lanes" id="lanes"></div>
      <div class="playhead" id="playhead"></div>
    </div>
  </div>
  <div class="status">
    <span>Time: <strong id="time">0.00s</strong></span>
    <span>Selection: <strong id="selInfo">‚Äî</strong></span>
    <span id="bpmEngine" class="chip">BPM engine: looking for Python server‚Ä¶</span>
    <span class="chip">‚å®Ô∏è Copy: Ctrl/Cmd+C ‚Ä¢ Paste: Ctrl/Cmd+V ‚Ä¢ Undo: Ctrl/Cmd+Z ‚Ä¢ Redo: Ctrl/Cmd+Y or Shift+Z</span>
  </div>
</div>

<script type="module">
/* ============================================================
   GLOBALS + UTILS
   ============================================================ */
const $ = s => document.querySelector(s);
const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
let serverOK = false;

let timeline = { pxPerSecond: 80, playing:false, startPlayPos:0, startCtxTime:0, scrollX:0, scrollY:0 };
let arrangement = { tracks:[], length:60 };
const COLORS = ['#6bf','#f68','#9f6','#ffb347','#c79cff','#5ff1e0'];
let trackId=1, clipId=1, selected=null;
let refBpm=null, refKey=null;

const undoStack=[]; const redoStack=[]; let suppressHistory=false; let clipboard=null;
const clipBuffers=new Map();

function snapshot(){ return JSON.parse(JSON.stringify({ arrangement, refBpm, refKey, trackId, clipId, selected })); }
function restore(state){ arrangement = state.arrangement; refBpm=state.refBpm; refKey=state.refKey; trackId=state.trackId; clipId=state.clipId; selected=state.selected; renderTracks(); }
function pushHistory(){ if(suppressHistory) return; undoStack.push(snapshot()); redoStack.length=0; }

function secondsToX(s){ return s * timeline.pxPerSecond; }
function xToSeconds(x){ return x / timeline.pxPerSecond; }
const clamp=(x,a,b)=>Math.min(b,Math.max(a,x));
const format = s => `${Math.max(0,s).toFixed(2)}s`;
function beatsToSeconds(b){ return 60/Number($('#bpmGrid').value) * b; }
const MIN_CLIP_LEN = 0.05;

/* ========================== GRID + RULER ========================== */
function updateGridBackground(){
  let px;
  const mode = $('#snapMode').value;
  if(mode==='sec') px = timeline.pxPerSecond * 1;
  else if(mode==='1/4') px = secondsToX(beatsToSeconds(0.25));
  else px = secondsToX(beatsToSeconds(1));
  document.documentElement.style.setProperty('--pxGrid', `${px}px`);
}
function niceSecondStep(){
  const candidates=[0.1,0.2,0.5,1,2,5,10,15,30,60];
  for(const s of candidates){ if(timeline.pxPerSecond*s >= 60) return s; }
  return 120;
}
function drawRuler(){
  const cvs=$('#ruler'); const width=Math.max(800, secondsToX(arrangement.length));
  cvs.width=width; cvs.height=36;
  const ctx=cvs.getContext('2d'); ctx.clearRect(0,0,width,36);
  ctx.fillStyle='#181818'; ctx.fillRect(0,0,width,36);
  const step = niceSecondStep();
  ctx.fillStyle='#222'; ctx.fillRect(0,34,width,2);
  ctx.textBaseline='top'; ctx.font='10px system-ui';
  for(let s=0; s<=arrangement.length; s+=step){
    const x=Math.round(secondsToX(s));
    ctx.fillStyle='#444'; ctx.fillRect(x,20,1,16);
    ctx.fillStyle='#aaa'; ctx.fillText(`${s.toFixed( (step<1)?1:0 )}s`, x+2, 4);
  }
  cvs.style.marginLeft = -timeline.scrollX+'px';
  positionPlayhead();
}

/* ========================== TRACKS + CLIPS ========================== */
function addTrack(){
  arrangement.tracks.push({ id:trackId++, name:`Track ${arrangement.tracks.length+1}`, color:COLORS[arrangement.tracks.length%COLORS.length], clip:null });
  renderTracks();
}
async function decodeFile(f){ const ab=await f.arrayBuffer(); return await audioCtx.decodeAudioData(ab); }
function buildPeaks(buffer, samples=1000){
  const ch=buffer.getChannelData(0), step=Math.ceil(ch.length/samples), peaks=[];
  for(let i=0;i<samples;i++){
    const s=i*step, e=Math.min((i+1)*step,ch.length);
    let min=1,max=-1; for(let j=s;j<e;j++){ const v=ch[j]; if(v>max)max=v; if(v<min)min=v; }
    peaks.push({min,max});
  } return peaks;
}
const clipLen = c => c.srcEnd - c.srcStart;
function ensureLength(end){ if(end>arrangement.length){ arrangement.length=Math.ceil(end+4); drawRuler(); } }

function drawPeaks(canvas, peaks, color){
  const ctx=canvas.getContext('2d'), w=canvas.width, h=canvas.height, mid=h/2, n=peaks.length, bar=w/n;
  ctx.clearRect(0,0,w,h); ctx.fillStyle=color;
  for(let i=0;i<n;i++){ const {min,max}=peaks[i]; const y1=mid+min*mid, y2=mid+max*mid; ctx.fillRect(i*bar, y1, Math.max(1,bar-0.5), Math.max(1,y2-y1)); }
}

function renderTracks(){
  updateGridBackground();
  const titles=$('#titles'), lanesWrap=$('#lanes'), timelines=$('#timelines');
  const keepX = timelines.scrollLeft, keepY = timelines.scrollTop;
  titles.innerHTML=''; lanesWrap.innerHTML='';

  arrangement.tracks.forEach(t=>{
    const title=document.createElement('div'); title.className='title-row';
    const metaStr = t.clip?`BPM: ${t.clip.bpmDetected}`:'‚Äî';
    title.innerHTML=`
      <div class="title-head">
        <strong style="color:${t.color}">${t.name}</strong>
        <label class="btn pill">Import<input type="file" accept="audio/*"></label>
        <div class="meta" id="meta-${t.id}">${metaStr}</div>
      </div>
    `;
    // File import handler gets patched later (Part 3)
    titles.appendChild(title);

    const lane=document.createElement('div'); lane.className='lane';
    lane.style.width = secondsToX(arrangement.length)+'px';
    if(t.clip){
      const c=t.clip, w = Math.max(20, secondsToX(clipLen(c)));
      const el=document.createElement('div'); el.className='clip';
      el.style.transform = `translateX(${secondsToX(c.pos)}px)`; el.style.width = `${w}px`; el.style.background = t.color;
      if(selected?.trackId===t.id) el.classList.add('selected');
      const wave=document.createElement('canvas'); wave.className='wave';
      wave.width = Math.max(60, secondsToX(clipLen(c))); wave.height=50;
      el.appendChild(wave); drawPeaks(wave, c.peaks, '#00000048');
      const label=document.createElement('div'); label.className='label'; label.textContent=c.name; el.appendChild(label);
      lane.appendChild(el);
    }
    lanesWrap.appendChild(lane);
  });
  drawRuler();
}

/* ========================== PLAYHEAD + TRANSPORT ========================== */
function getPlayhead(){ if(!timeline.playing) return timeline.startPlayPos; return timeline.startPlayPos + (audioCtx.currentTime - timeline.startCtxTime); }
function setPlayhead(sec){ timeline.startPlayPos = clamp(sec,0,arrangement.length); if(!timeline.playing) positionPlayhead(); $('#time').textContent = format(sec); }
function positionPlayhead(){ const scroller = document.getElementById('timelines'); const x = secondsToX(getPlayhead()) - scroller.scrollLeft; document.getElementById('playhead').style.left = `${x}px`; }

let scheduled=[];
function stopPlayback(updateTimeText=true){
  scheduled.forEach(n=>{ try{n.stop(0)}catch{} }); scheduled=[];
  timeline.playing=false;
  if(updateTimeText) $('#time').textContent = format(getPlayhead());
  positionPlayhead();
}
function play(){
  if(timeline.playing) return;
  timeline.playing=true; timeline.startCtxTime=audioCtx.currentTime;
  const when0=audioCtx.currentTime + 0.05, from=timeline.startPlayPos;
  arrangement.tracks.forEach(t=>{
    const c=t.clip; if(!c) return;
    const len=clipLen(c), start=c.pos, end=start+len; if(end<=from) return;
    const delay=Math.max(0,start-from), playAt=when0+delay;
    const srcOffset=(from>start)?(c.srcStart+(from-start)):c.srcStart;
    const dur=Math.max(0.0001, len - Math.max(0, from-start));
    const node=audioCtx.createBufferSource(); node.buffer=c.buffer;
    node.connect(audioCtx.destination);
    try{ node.start(playAt, srcOffset, dur); scheduled.push(node);}catch(e){}
  });
  const tick=()=>{ if(!timeline.playing) return;
    $('#time').textContent = format(getPlayhead()); positionPlayhead();
    if(getPlayhead()>=arrangement.length){ stopPlayback(); return; }
    requestAnimationFrame(tick);
  };
  requestAnimationFrame(tick);
}
/* ============================================================
   SERATO-STYLE TEMPO DETECTOR
   ============================================================ */

// helper: fold BPM into range (avoid half/double errors)
function foldBpm(b, lo=70, hi=180){
  if(!isFinite(b)||b<=0) return 0;
  while(b>hi) b/=2;
  while(b<lo) b*=2;
  return Math.round(b);
}

// call Python server for one segment
async function analyzeSegment(file, startSec, durSec){
  const fd=new FormData();
  fd.append("file", file);
  fd.append("start", startSec);
  fd.append("duration", durSec);
  try{
    const res=await fetch("/api/analyze",{method:"POST",body:fd});
    if(!res.ok) throw new Error("bad HTTP");
    return await res.json();
  }catch(e){ console.warn("segment fail",e); return null; }
}

// consensus from multiple candidates
function consensusBpm(cands){
  if(!cands.length) return {bpm:120, confidence:0};
  const folded=cands.map(c=>foldBpm(c));
  const freq={};
  folded.forEach(f=>{ if(f) freq[f]=(freq[f]||0)+1; });
  let best=null,bestCnt=-1;
  Object.entries(freq).forEach(([b,c])=>{
    if(c>bestCnt){ best=Number(b); bestCnt=c; }
  });
  return {bpm:best||120, confidence:bestCnt/cands.length};
}

// onset-based anchor (very simple: RMS threshold)
function estimateBeatGridAnchor(buf){
  const ch=buf.getChannelData(0);
  let rms=0; for(let i=0;i<ch.length;i++){ rms+=ch[i]*ch[i]; }
  rms=Math.sqrt(rms/ch.length)||1;
  for(let i=0;i<ch.length;i++){
    if(Math.abs(ch[i])>rms*2.5) return i/buf.sampleRate;
  }
  return 0;
}

// full detector: segment + consensus + onset anchor
async function detectTempoSeratoStyle(file, buf){
  const dur=buf.duration;
  const window=20; // 20s chunks
  const segs=[];
  for(let t=0;t<dur;t+=window){
    const r=await analyzeSegment(file,t,window);
    if(r&&r.bpm) segs.push(r.bpm);
  }
  let {bpm,confidence}=consensusBpm(segs);
  if(!bpm||bpm<=0){
    // fallback: web-audio-beat-detector
    try{
      const mod=await import("https://cdn.skypack.dev/web-audio-beat-detector@8");
      bpm=foldBpm(await mod.analyze(buf));
      confidence=0.25;
    }catch{ bpm=120; confidence=0; }
  }
  const anchor=estimateBeatGridAnchor(buf);
  return {bpm,confidence,anchor};
}

/* ============================================================
   FILE IMPORT HANDLER (uses new detector)
   ============================================================ */

function wireImportHandler(titleEl,track){
  titleEl.querySelector('input[type=file]').addEventListener('change', async e=>{
    const f=e.target.files?.[0]; if(!f) return;
    const buf=await decodeFile(f);

    // detect tempo/key
    const {bpm,confidence,anchor} = await detectTempoSeratoStyle(f,buf);
    if(refBpm==null){
      refBpm=bpm;
      $('#bpmGrid').value=String(bpm);
    }
    const clip={
      id:clipId++, name:f.name, buffer:buf, origFile:f,
      bpmDetected:bpm, bpmAlias:bpm,
      srcStart:0, srcEnd:buf.duration,
      pos:anchor,
      peaks:buildPeaks(buf,1200)
    };
    track.clip=clip;
    clipBuffers.set(clip.id,{buffer:buf,peaks:clip.peaks,origFile:f});
    ensureLength(clip.pos+clipLen(clip));
    document.getElementById('meta-'+track.id).textContent=`BPM: ${bpm} (conf ${confidence.toFixed(2)})`;
    pushHistory(); renderTracks();
  });
}

// patch renderTracks so it wires handler
const _renderTracks=renderTracks;
renderTracks=function(){
  updateGridBackground();
  const titles=$('#titles'); const lanesWrap=$('#lanes');
  const timelines=$('#timelines');
  const keepX=timelines.scrollLeft, keepY=timelines.scrollTop;
  titles.innerHTML=''; lanesWrap.innerHTML='';
  arrangement.tracks.forEach(t=>{
    const title=document.createElement('div'); title.className='title-row';
    title.innerHTML=`
      <div class="title-head">
        <strong style="color:${t.color}">${t.name}</strong>
        <label class="btn pill">Import<input type="file" accept="audio/*"></label>
        <div class="meta" id="meta-${t.id}">${t.clip?('BPM: '+t.clip.bpmDetected):'‚Äî'}</div>
      </div>`;
    wireImportHandler(title,t);
    titles.appendChild(title);

    const lane=document.createElement('div'); lane.className='lane';
    lane.style.width=secondsToX(arrangement.length)+'px';
    if(t.clip){
      const c=t.clip, w=Math.max(20,secondsToX(clipLen(c)));
      const el=document.createElement('div'); el.className='clip';
      el.style.transform=`translateX(${secondsToX(c.pos)}px)`; el.style.width=`${w}px`; el.style.background=t.color;
      const wave=document.createElement('canvas'); wave.className='wave';
      wave.width=Math.max(60,secondsToX(clipLen(c))); wave.height=50;
      el.appendChild(wave); drawPeaks(wave,c.peaks,'#00000048');
      const label=document.createElement('div'); label.className='label'; label.textContent=c.name; el.appendChild(label);
      lane.appendChild(el);
    }
    lanesWrap.appendChild(lane);
  });
  drawRuler();
}
/* ============================================================
   CONTROLS + SHORTCUTS
   ============================================================ */
$('#addTrack').onclick=()=>{ pushHistory(); addTrack(); };
$('#play').onclick=()=>{ audioCtx.resume(); play(); };
$('#stop').onclick=()=>stopPlayback();

window.addEventListener('keydown',e=>{
  if(e.metaKey||e.ctrlKey){
    if(e.key.toLowerCase()==='z' && !e.shiftKey){
      e.preventDefault();
      if(undoStack.length){ const cur=snapshot(); const s=undoStack.pop(); redoStack.push(cur); restore(s); }
    }
    if((e.key.toLowerCase()==='y') || (e.key.toLowerCase()==='z' && e.shiftKey)){
      e.preventDefault();
      if(redoStack.length){ const cur=snapshot(); const s=redoStack.pop(); undoStack.push(cur); restore(s); }
    }
  }
});

/* ============================================================
   INIT
   ============================================================ */
function init(){
  timeline.pxPerSecond = Number($('#zoom').value);
  pushHistory(); addTrack(); addTrack();
  updateGridBackground(); renderTracks();
}
init();
</script>
</body>
</html>
